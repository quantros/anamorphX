"""
JavaScript Code Generator for AnamorphX

Генератор JavaScript кода из AST программ Anamorph.
Поддерживает современный ES2020+ синтаксис и нейронные операции.
"""

import os
import sys
import time
from typing import Any, Dict, List, Optional, Union

# Добавляем пути для импортов
current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
for path in [current_dir, parent_dir]:
    if path not in sys.path:
        sys.path.insert(0, path)

from .base_codegen import (
    BaseCodeGenerator, CodeGenConfig, CodeGenResult, 
    TargetLanguage, OptimizationLevel, ASTVisitor
)


class JavaScriptCodeGenerator(BaseCodeGenerator, ASTVisitor):
    """
    Генератор JavaScript кода из AST Anamorph.
    
    Поддерживает:
    - Современный ES2020+ синтаксис
    - Классы и модули
    - Async/await
    - Нейронные операции
    - TypeScript типы (опционально)
    """
    
    def __init__(self, config: CodeGenConfig = None):
        if config is None:
            config = CodeGenConfig(target_language=TargetLanguage.JAVASCRIPT)
        
        super().__init__(config)
        
        # JavaScript-специфичные настройки
        self.js_keywords = {
            'abstract', 'arguments', 'await', 'boolean', 'break', 'byte',
            'case', 'catch', 'char', 'class', 'const', 'continue',
            'debugger', 'default', 'delete', 'do', 'double', 'else',
            'enum', 'eval', 'export', 'extends', 'false', 'final',
            'finally', 'float', 'for', 'function', 'goto', 'if',
            'implements', 'import', 'in', 'instanceof', 'int', 'interface',
            'let', 'long', 'native', 'new', 'null', 'package', 'private',
            'protected', 'public', 'return', 'short', 'static', 'super',
            'switch', 'synchronized', 'this', 'throw', 'throws',
            'transient', 'true', 'try', 'typeof', 'var', 'void',
            'volatile', 'while', 'with', 'yield'
        }
        
        # Маппинг типов Anamorph -> JavaScript/TypeScript
        self.type_mapping = {
            'int': 'number',
            'float': 'number',
            'string': 'string',
            'bool': 'boolean',
            'list': 'Array',
            'dict': 'Object',
            'neuron': 'Neuron',
            'synapse': 'Synapse',
            'signal': 'Signal',
            'pulse': 'Pulse',
            'network': 'NeuralNetwork'
        }
        
        # Определяем использование TypeScript
        self.use_typescript = config.javascript_target.lower().startswith('typescript') or \
                            config.target_language == TargetLanguage.TYPESCRIPT
    
    def get_target_language(self) -> TargetLanguage:
        """Возвращает целевой язык - JavaScript."""
        return TargetLanguage.JAVASCRIPT
    
    def generate_program(self, ast) -> CodeGenResult:
        """Генерирует JavaScript код для всей программы."""
        start_time = time.time()
        
        try:
            # Очищаем предыдущий код
            self.clear_generated_code()
            
            # Добавляем заголовок
            self._generate_header()
            
            # Генерируем импорты
            self._generate_imports()
            
            # Генерируем нейронные классы
            self._generate_neural_classes()
            
            # Обрабатываем AST
            if hasattr(ast, 'body') and ast.body:
                for node in ast.body:
                    self.visit(node)
                    self.stats['nodes_processed'] += 1
            else:
                # Простая демонстрация если AST пустой
                self._generate_demo_program()
            
            # Генерируем main функцию если нужно
            if self.config.generate_tests:
                self._generate_test_main()
            
            # Добавляем экспорты
            self._generate_exports()
            
            return self.create_result(start_time)
            
        except Exception as e:
            self.add_error(f"Code generation failed: {e}")
            return self.create_result(start_time)
    
    def _generate_header(self):
        """Генерирует заголовок файла."""
        if self.use_typescript:
            self.emit_line("// TypeScript Generated Code")
        else:
            self.emit_line("// JavaScript Generated Code")
        
        self.emit_line("// Generated by AnamorphX Code Generator")
        self.emit_line(f"// Target: {self.config.javascript_target}")
        self.emit_line(f"// Generation Time: {time.strftime('%Y-%m-%d %H:%M:%S')}")
        self.emit_blank_line()
        
        # Строгий режим
        self.emit_line('"use strict";')
        self.emit_blank_line()
    
    def _generate_imports(self):
        """Генерирует импорты."""
        # Пользовательские импорты
        for custom_import in self.config.custom_imports:
            self.emit_line(custom_import)
        
        if self.config.custom_imports:
            self.emit_blank_line()
    
    def _generate_neural_classes(self):
        """Генерирует базовые нейронные классы."""
        self.emit_line("// Neural Network Base Classes")
        self.emit_blank_line()
        
        # Класс Neuron
        if self.use_typescript:
            self.emit_line("interface NeuronConfig {")
            self.increase_indent()
            self.emit_line("id: string;")
            self.emit_line("threshold?: number;")
            self.emit_line("activation?: number;")
            self.decrease_indent()
            self.emit_line("}")
            self.emit_blank_line()
        
        self.emit_line("class Neuron {")
        self.increase_indent()
        
        if self.use_typescript:
            self.emit_line("public id: string;")
            self.emit_line("public activation: number = 0.0;")
            self.emit_line("public threshold: number = 1.0;")
            self.emit_line("public connections: Synapse[] = [];")
            self.emit_blank_line()
            
            self.emit_line("constructor(config: NeuronConfig) {")
        else:
            self.emit_line("constructor(config) {")
        
        self.increase_indent()
        self.emit_line("this.id = config.id;")
        self.emit_line("this.activation = config.activation || 0.0;")
        self.emit_line("this.threshold = config.threshold || 1.0;")
        self.emit_line("this.connections = [];")
        self.decrease_indent()
        self.emit_line("}")
        self.emit_blank_line()
        
        # Метод activate
        if self.use_typescript:
            self.emit_line("activate(inputSignal: number): number {")
        else:
            self.emit_line("activate(inputSignal) {")
        
        self.increase_indent()
        self.emit_line("this.activation = inputSignal;")
        self.emit_line("return this.activation >= this.threshold ? this.activation : 0.0;")
        self.decrease_indent()
        self.emit_line("}")
        self.emit_blank_line()
        
        # Метод fire
        if self.use_typescript:
            self.emit_line("fire(): boolean {")
        else:
            self.emit_line("fire() {")
        
        self.increase_indent()
        self.emit_line("return this.activation >= this.threshold;")
        self.decrease_indent()
        self.emit_line("}")
        
        self.decrease_indent()
        self.emit_line("}")
        self.emit_blank_line()
        
        # Класс Synapse
        if self.use_typescript:
            self.emit_line("interface SynapseConfig {")
            self.increase_indent()
            self.emit_line("source: Neuron;")
            self.emit_line("target: Neuron;")
            self.emit_line("weight?: number;")
            self.emit_line("delay?: number;")
            self.decrease_indent()
            self.emit_line("}")
            self.emit_blank_line()
        
        self.emit_line("class Synapse {")
        self.increase_indent()
        
        if self.use_typescript:
            self.emit_line("public source: Neuron;")
            self.emit_line("public target: Neuron;")
            self.emit_line("public weight: number = 1.0;")
            self.emit_line("public delay: number = 0.0;")
            self.emit_blank_line()
            
            self.emit_line("constructor(config: SynapseConfig) {")
        else:
            self.emit_line("constructor(config) {")
        
        self.increase_indent()
        self.emit_line("this.source = config.source;")
        self.emit_line("this.target = config.target;")
        self.emit_line("this.weight = config.weight || 1.0;")
        self.emit_line("this.delay = config.delay || 0.0;")
        self.decrease_indent()
        self.emit_line("}")
        self.emit_blank_line()
        
        # Метод transmit
        if self.use_typescript:
            self.emit_line("transmit(signal: number): number {")
        else:
            self.emit_line("transmit(signal) {")
        
        self.increase_indent()
        self.emit_line("return signal * this.weight;")
        self.decrease_indent()
        self.emit_line("}")
        
        self.decrease_indent()
        self.emit_line("}")
        self.emit_blank_line()
        
        # Класс Signal
        if self.use_typescript:
            self.emit_line("interface SignalConfig {")
            self.increase_indent()
            self.emit_line("value: number;")
            self.emit_line("timestamp?: number;")
            self.emit_line("sourceId?: string;")
            self.emit_line("metadata?: any;")
            self.decrease_indent()
            self.emit_line("}")
            self.emit_blank_line()
        
        self.emit_line("class Signal {")
        self.increase_indent()
        
        if self.use_typescript:
            self.emit_line("public value: number;")
            self.emit_line("public timestamp: number;")
            self.emit_line("public sourceId?: string;")
            self.emit_line("public metadata: any = {};")
            self.emit_blank_line()
            
            self.emit_line("constructor(config: SignalConfig) {")
        else:
            self.emit_line("constructor(config) {")
        
        self.increase_indent()
        self.emit_line("this.value = config.value;")
        self.emit_line("this.timestamp = config.timestamp || Date.now();")
        self.emit_line("this.sourceId = config.sourceId;")
        self.emit_line("this.metadata = config.metadata || {};")
        self.decrease_indent()
        self.emit_line("}")
        
        self.decrease_indent()
        self.emit_line("}")
        self.emit_blank_line()
        
        # Класс Pulse
        if self.use_typescript:
            self.emit_line("interface PulseConfig {")
            self.increase_indent()
            self.emit_line("amplitude: number;")
            self.emit_line("frequency: number;")
            self.emit_line("duration: number;")
            self.emit_line("phase?: number;")
            self.decrease_indent()
            self.emit_line("}")
            self.emit_blank_line()
        
        self.emit_line("class Pulse {")
        self.increase_indent()
        
        if self.use_typescript:
            self.emit_line("public amplitude: number;")
            self.emit_line("public frequency: number;")
            self.emit_line("public duration: number;")
            self.emit_line("public phase: number = 0.0;")
            self.emit_blank_line()
            
            self.emit_line("constructor(config: PulseConfig) {")
        else:
            self.emit_line("constructor(config) {")
        
        self.increase_indent()
        self.emit_line("this.amplitude = config.amplitude;")
        self.emit_line("this.frequency = config.frequency;")
        self.emit_line("this.duration = config.duration;")
        self.emit_line("this.phase = config.phase || 0.0;")
        self.decrease_indent()
        self.emit_line("}")
        
        self.decrease_indent()
        self.emit_line("}")
        self.emit_blank_line()
        
        # Класс NeuralNetwork
        self.emit_line("class NeuralNetwork {")
        self.increase_indent()
        
        if self.use_typescript:
            self.emit_line("private neurons: Map<string, Neuron> = new Map();")
            self.emit_line("private synapses: Synapse[] = [];")
            self.emit_line("private signals: Signal[] = [];")
            self.emit_blank_line()
        
        self.emit_line("constructor() {")
        self.increase_indent()
        if not self.use_typescript:
            self.emit_line("this.neurons = new Map();")
            self.emit_line("this.synapses = [];")
            self.emit_line("this.signals = [];")
        self.decrease_indent()
        self.emit_line("}")
        self.emit_blank_line()
        
        # Метод addNeuron
        if self.use_typescript:
            self.emit_line("addNeuron(neuron: Neuron): void {")
        else:
            self.emit_line("addNeuron(neuron) {")
        
        self.increase_indent()
        self.emit_line("this.neurons.set(neuron.id, neuron);")
        self.decrease_indent()
        self.emit_line("}")
        self.emit_blank_line()
        
        # Метод connect
        if self.use_typescript:
            self.emit_line("connect(sourceId: string, targetId: string, weight: number = 1.0): void {")
        else:
            self.emit_line("connect(sourceId, targetId, weight = 1.0) {")
        
        self.increase_indent()
        self.emit_line("const source = this.neurons.get(sourceId);")
        self.emit_line("const target = this.neurons.get(targetId);")
        self.emit_blank_line()
        
        self.emit_line("if (source && target) {")
        self.increase_indent()
        self.emit_line("const synapse = new Synapse({")
        self.increase_indent()
        self.emit_line("source: source,")
        self.emit_line("target: target,")
        self.emit_line("weight: weight")
        self.decrease_indent()
        self.emit_line("});")
        self.emit_blank_line()
        
        self.emit_line("this.synapses.push(synapse);")
        self.emit_line("source.connections.push(synapse);")
        self.decrease_indent()
        self.emit_line("}")
        self.decrease_indent()
        self.emit_line("}")
        self.emit_blank_line()
        
        # Метод processSignal
        if self.use_typescript:
            self.emit_line("async processSignal(signal: Signal): Promise<Signal[]> {")
        else:
            self.emit_line("async processSignal(signal) {")
        
        self.increase_indent()
        self.emit_line("const outputSignals = [];")
        self.emit_line("// Signal processing logic here")
        self.emit_line("return outputSignals;")
        self.decrease_indent()
        self.emit_line("}")
        
        self.decrease_indent()
        self.emit_line("}")
        self.emit_blank_line()
    
    def _generate_demo_program(self):
        """Генерирует демонстрационную программу."""
        self.emit_line("// Demo Anamorph Program")
        self.emit_blank_line()
        
        if self.use_typescript:
            self.emit_line("function createSimpleNetwork(): NeuralNetwork {")
        else:
            self.emit_line("function createSimpleNetwork() {")
        
        self.increase_indent()
        self.emit_line("const network = new NeuralNetwork();")
        self.emit_blank_line()
        
        self.emit_line("// Create neurons")
        self.emit_line("const inputNeuron = new Neuron({ id: 'input', threshold: 0.5 });")
        self.emit_line("const hiddenNeuron = new Neuron({ id: 'hidden', threshold: 0.7 });")
        self.emit_line("const outputNeuron = new Neuron({ id: 'output', threshold: 0.8 });")
        self.emit_blank_line()
        
        self.emit_line("// Add to network")
        self.emit_line("network.addNeuron(inputNeuron);")
        self.emit_line("network.addNeuron(hiddenNeuron);")
        self.emit_line("network.addNeuron(outputNeuron);")
        self.emit_blank_line()
        
        self.emit_line("// Create connections")
        self.emit_line("network.connect('input', 'hidden', 0.8);")
        self.emit_line("network.connect('hidden', 'output', 0.9);")
        self.emit_blank_line()
        
        self.emit_line("return network;")
        self.decrease_indent()
        self.emit_line("}")
        self.emit_blank_line()
        
        self.stats['functions_generated'] += 1
    
    def _generate_test_main(self):
        """Генерирует main функцию для тестирования."""
        self.emit_line("async function main() {")
        self.increase_indent()
        self.emit_line("console.log('AnamorphX Neural Network Demo');")
        self.emit_line("console.log('='.repeat(40));")
        self.emit_blank_line()
        
        self.emit_line("// Create network")
        self.emit_line("const network = createSimpleNetwork();")
        self.emit_line("console.log(`Created network with ${network.neurons.size} neurons`);")
        self.emit_blank_line()
        
        self.emit_line("// Test activation")
        self.emit_line("const inputNeuron = network.neurons.get('input');")
        self.emit_line("const activation = inputNeuron.activate(1.0);")
        self.emit_line("console.log(`Input neuron activation: ${activation}`);")
        self.emit_blank_line()
        
        self.emit_line("// Create and process signal")
        self.emit_line("const signal = new Signal({ value: 1.5, timestamp: Date.now() });")
        self.emit_line("const outputSignals = await network.processSignal(signal);")
        self.emit_line("console.log(`Processed signal, got ${outputSignals.length} outputs`);")
        self.emit_blank_line()
        
        self.emit_line("console.log('Demo completed successfully!');")
        self.decrease_indent()
        self.emit_line("}")
        self.emit_blank_line()
        
        self.stats['functions_generated'] += 1
    
    def _generate_exports(self):
        """Генерирует экспорты модуля."""
        self.emit_line("// Module exports")
        if self.config.javascript_target.startswith('node') or 'module' in self.config.javascript_target.lower():
            self.emit_line("module.exports = {")
            self.increase_indent()
            self.emit_line("Neuron,")
            self.emit_line("Synapse,")
            self.emit_line("Signal,")
            self.emit_line("Pulse,")
            self.emit_line("NeuralNetwork,")
            self.emit_line("createSimpleNetwork")
            self.decrease_indent()
            self.emit_line("};")
        else:
            # ES6 exports
            self.emit_line("export {")
            self.increase_indent()
            self.emit_line("Neuron,")
            self.emit_line("Synapse,")
            self.emit_line("Signal,")
            self.emit_line("Pulse,")
            self.emit_line("NeuralNetwork,")
            self.emit_line("createSimpleNetwork")
            self.decrease_indent()
            self.emit_line("};")
        
        self.emit_blank_line()
        
        # Запуск main если это не модуль
        if self.config.generate_tests:
            self.emit_line("// Run main if not imported as module")
            if self.config.javascript_target.startswith('node'):
                self.emit_line("if (require.main === module) {")
                self.increase_indent()
                self.emit_line("main().catch(console.error);")
                self.decrease_indent()
                self.emit_line("}")
            else:
                self.emit_line("if (typeof window !== 'undefined') {")
                self.increase_indent()
                self.emit_line("main().catch(console.error);")
                self.decrease_indent()
                self.emit_line("}")
    
    # Методы для генерации различных узлов AST
    
    def generate_function(self, node) -> str:
        """Генерирует JavaScript функцию."""
        func_name = getattr(node, 'name', 'unnamedFunction')
        
        # Проверяем на конфликт с ключевыми словами
        if func_name in self.js_keywords:
            func_name = f"anamorph{func_name.capitalize()}"
            self.add_warning(f"Function name conflicts with JavaScript keyword, renamed to {func_name}")
        
        # Регистрируем функцию
        self.register_symbol(func_name, 'function')
        
        # Генерируем параметры
        params = getattr(node, 'parameters', [])
        param_list = []
        
        for param in params:
            param_name = getattr(param, 'name', 'param')
            param_type = getattr(param, 'type', None)
            
            if self.use_typescript and param_type and param_type in self.type_mapping:
                param_list.append(f"{param_name}: {self.type_mapping[param_type]}")
            else:
                param_list.append(param_name)
        
        # Определяем асинхронность
        is_async = getattr(node, 'is_async', False) or self.config.async_support
        async_keyword = "async " if is_async else ""
        
        # Определяем тип возвращаемого значения
        return_type = ""
        if self.use_typescript:
            ret_type = getattr(node, 'return_type', None)
            if ret_type and ret_type in self.type_mapping:
                return_type = f": {self.type_mapping[ret_type]}"
            elif is_async:
                return_type = ": Promise<any>"
            else:
                return_type = ": any"
        
        # Генерируем функцию
        signature = f"{async_keyword}function {func_name}({', '.join(param_list)}){return_type} {{"
        self.emit_line(signature)
        
        self.increase_indent()
        
        # Генерируем тело функции
        if hasattr(node, 'body') and node.body:
            for stmt in node.body:
                self.visit(stmt)
        else:
            self.emit_line("// Empty function body")
        
        self.decrease_indent()
        self.emit_line("}")
        self.emit_blank_line()
        
        self.stats['functions_generated'] += 1
        return signature
    
    def generate_variable(self, node) -> str:
        """Генерирует объявление переменной."""
        var_name = getattr(node, 'name', 'unnamedVar')
        var_type = getattr(node, 'type', None)
        var_value = getattr(node, 'value', None)
        is_const = getattr(node, 'is_const', False)
        
        # Проверяем на конфликт с ключевыми словами
        if var_name in self.js_keywords:
            var_name = f"anamorph{var_name.capitalize()}"
            self.add_warning(f"Variable name conflicts with JavaScript keyword, renamed to {var_name}")
        
        # Регистрируем переменную
        self.register_symbol(var_name, var_type or 'unknown')
        
        # Выбираем ключевое слово
        keyword = "const" if is_const else "let"
        
        # Добавляем тип для TypeScript
        type_annotation = ""
        if self.use_typescript and var_type and var_type in self.type_mapping:
            type_annotation = f": {self.type_mapping[var_type]}"
        
        # Генерируем объявление
        if var_value is not None:
            value_code = self.generate_expression(var_value)
            declaration = f"{keyword} {var_name}{type_annotation} = {value_code};"
        else:
            # Значение по умолчанию в зависимости от типа
            default_values = {
                'int': '0',
                'float': '0.0',
                'string': '""',
                'bool': 'false',
                'list': '[]',
                'dict': '{}',
                'neuron': 'new Neuron({ id: "default" })',
                'signal': 'new Signal({ value: 0.0 })'
            }
            default_value = default_values.get(var_type, 'null')
            declaration = f"{keyword} {var_name}{type_annotation} = {default_value};"
        
        self.emit_line(declaration)
        self.stats['variables_declared'] += 1
        return declaration
    
    def generate_expression(self, node) -> str:
        """Генерирует выражение."""
        if node is None:
            return "null"
        
        # Простые значения
        if isinstance(node, (int, float)):
            return str(node)
        elif isinstance(node, str):
            return f'"{node}"'
        elif isinstance(node, bool):
            return "true" if node else "false"
        
        # Если это объект с атрибутами
        if hasattr(node, 'type'):
            expr_type = node.type
            
            if expr_type == 'literal':
                value = getattr(node, 'value', None)
                if isinstance(value, str):
                    return f'"{value}"'
                elif isinstance(value, bool):
                    return "true" if value else "false"
                return str(value)
            
            elif expr_type == 'identifier':
                return getattr(node, 'name', 'unknown')
            
            elif expr_type == 'binary_op':
                left = self.generate_expression(getattr(node, 'left', None))
                right = self.generate_expression(getattr(node, 'right', None))
                operator = getattr(node, 'operator', '+')
                return f"({left} {operator} {right})"
            
            elif expr_type == 'function_call':
                func_name = getattr(node, 'name', 'unknown')
                args = getattr(node, 'arguments', [])
                arg_list = [self.generate_expression(arg) for arg in args]
                return f"{func_name}({', '.join(arg_list)})"
        
        return str(node)
    
    def generate_neural_operation(self, node) -> str:
        """Генерирует нейронную операцию."""
        operation_type = getattr(node, 'operation', 'unknown')
        
        if operation_type == 'create_neuron':
            neuron_id = getattr(node, 'id', 'neuron')
            threshold = getattr(node, 'threshold', 1.0)
            return f'new Neuron({{ id: "{neuron_id}", threshold: {threshold} }})'
        
        elif operation_type == 'create_synapse':
            source = getattr(node, 'source', 'source')
            target = getattr(node, 'target', 'target')
            weight = getattr(node, 'weight', 1.0)
            return f'new Synapse({{ source: {source}, target: {target}, weight: {weight} }})'
        
        elif operation_type == 'send_signal':
            signal_value = getattr(node, 'value', 0.0)
            target = getattr(node, 'target', 'target')
            return f'{target}.activate({signal_value})'
        
        elif operation_type == 'create_pulse':
            amplitude = getattr(node, 'amplitude', 1.0)
            frequency = getattr(node, 'frequency', 1.0)
            duration = getattr(node, 'duration', 1.0)
            return f'new Pulse({{ amplitude: {amplitude}, frequency: {frequency}, duration: {duration} }})'
        
        self.stats['neural_operations'] += 1
        return f"// Neural operation: {operation_type}"
    
    def _format_comment_block(self, lines: List[str]) -> str:
        """Форматирует блок комментариев для JavaScript."""
        if not lines:
            return ""
        
        comment_lines = ['/**']
        for line in lines:
            comment_lines.append(f' * {line}')
        comment_lines.append(' */')
        
        return '\n'.join(comment_lines)
    
    # Visitor методы для различных типов узлов
    
    def visit_program(self, node):
        """Посещает корневой узел программы."""
        if hasattr(node, 'statements'):
            for stmt in node.statements:
                self.visit(stmt)
    
    def visit_function_definition(self, node):
        """Посещает определение функции."""
        return self.generate_function(node)
    
    def visit_variable_declaration(self, node):
        """Посещает объявление переменной."""
        return self.generate_variable(node)
    
    def visit_assignment(self, node):
        """Посещает присваивание."""
        target = getattr(node, 'target', 'unknown')
        value = self.generate_expression(getattr(node, 'value', None))
        assignment = f"{target} = {value};"
        self.emit_line(assignment)
        return assignment
    
    def visit_expression_statement(self, node):
        """Посещает выражение-утверждение."""
        expr = self.generate_expression(getattr(node, 'expression', None))
        self.emit_line(f"{expr};")
        return expr
    
    def visit_neural_operation(self, node):
        """Посещает нейронную операцию."""
        operation = self.generate_neural_operation(node)
        self.emit_line(f"{operation};")
        return operation
    
    def visit_if_statement(self, node):
        """Посещает условное утверждение."""
        condition = self.generate_expression(getattr(node, 'condition', None))
        self.emit_line(f"if ({condition}) {{")
        
        self.increase_indent()
        if hasattr(node, 'then_body'):
            for stmt in node.then_body:
                self.visit(stmt)
        else:
            self.emit_line("// Empty if body")
        self.decrease_indent()
        
        if hasattr(node, 'else_body') and node.else_body:
            self.emit_line("} else {")
            self.increase_indent()
            for stmt in node.else_body:
                self.visit(stmt)
            self.decrease_indent()
        
        self.emit_line("}")
    
    def visit_while_loop(self, node):
        """Посещает цикл while."""
        condition = self.generate_expression(getattr(node, 'condition', None))
        self.emit_line(f"while ({condition}) {{")
        
        self.increase_indent()
        if hasattr(node, 'body'):
            for stmt in node.body:
                self.visit(stmt)
        else:
            self.emit_line("// Empty while body")
        self.decrease_indent()
        
        self.emit_line("}")
    
    def visit_for_loop(self, node):
        """Посещает цикл for."""
        variable = getattr(node, 'variable', 'i')
        iterable = self.generate_expression(getattr(node, 'iterable', None))
        self.emit_line(f"for (const {variable} of {iterable}) {{")
        
        self.increase_indent()
        if hasattr(node, 'body'):
            for stmt in node.body:
                self.visit(stmt)
        else:
            self.emit_line("// Empty for body")
        self.decrease_indent()
        
        self.emit_line("}")
    
    def visit_return_statement(self, node):
        """Посещает оператор return."""
        if hasattr(node, 'value') and node.value is not None:
            value = self.generate_expression(node.value)
            self.emit_line(f"return {value};")
        else:
            self.emit_line("return;")


# Утилиты для быстрого использования
def generate_javascript_code(ast, config: CodeGenConfig = None) -> CodeGenResult:
    """Быстрая генерация JavaScript кода из AST."""
    generator = JavaScriptCodeGenerator(config)
    return generator.generate_program(ast)


def save_javascript_code(ast, filename: str, config: CodeGenConfig = None) -> bool:
    """Генерирует и сохраняет JavaScript код в файл."""
    result = generate_javascript_code(ast, config)
    
    if result.success:
        generator = JavaScriptCodeGenerator(config)
        return generator.save_to_file(result.generated_code, filename)
    
    return False


# Экспорт
__all__ = [
    'JavaScriptCodeGenerator',
    'generate_javascript_code',
    'save_javascript_code'
] 